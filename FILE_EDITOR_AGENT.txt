# Gemini Agent: File Editor App (Text Editor)

## 1. High-Level Goal
Build the full-page Text Editor app. It appears in the Apps Launcher as “File Editor” (name quirk is intentional) and runs at `/app/file_editor` inside the App Container. The goal is a simple, reliable text editor that can open, edit, and save files in the user’s home directory.

## 2. CRITICAL: Development Guardrails
1. DO NOT MODIFY CORE FILES.
2. WORK ONLY WITHIN YOUR APP DIRECTORY: `/app/apps/file_editor/`.
3. Follow API response conventions: all backend responses must be `{ ok: true|false, data|error }`.

## 3. Provided Runtime and APIs

The framework loads this app’s `template.html` and `main.js` into a generic app shell and injects two helpers into your module entry: `api` and `host`.

- Module entry signature: `export default function(container, api, host) { ... }`

- `api` (per‑app backend under `/api/app/file_editor`):
  - `api.get(endpoint)` → `GET /api/app/file_editor/<endpoint>`
  - `api.post(endpoint, body)` → `POST /api/app/file_editor/<endpoint>`
  - `api.delete(endpoint)` → `DELETE /api/app/file_editor/<endpoint>`

- `host` (app container host API):
  - `host.id` → `'file_editor'`
  - `host.setTitle(title)` → sets page and toolbar title
  - `host.saveState(stateObj)` / `host.loadState(default)` / `host.clearState()` → lightweight session state via `localStorage`
  - `host.onBeforeExit(handler)` → optional handler invoked on Home/Reload/leave; you may return `{ cancel: true }` to block, or a state object to persist
  - `host.toast(message)` → shows a toast via the shared UI, if available

- Core endpoints (shared across apps):
  - `GET /api/browse?path=~` → list files/directories for file picker UI
  - `POST /api/run_command` → generic shell command (use sparingly)

## 4. App Backend Endpoints (Already Available)
- `GET /api/app/file_editor/read?path=<abs_path>`
  - Returns: `{ ok: true, data: { path, content } }`
- `POST /api/app/file_editor/write`
  - Body: `{ "path": "<abs_path>", "content": "..." }`
  - Returns: `{ ok: true, data: { path } }`
- Safety: Paths are restricted to the user’s home directory; non‑home paths are rejected.

## 5. Implementation Tasks

1) Editor UI (template.html)
- Add a compact header row within the app content area:
  - File path input (`<input>`), an “Open” button, a “Save” button, and a “Browse” button (folder icon). The container shell already has global Home/Reload.
- Add a large `<textarea id="editor">` that fills remaining vertical space (flex or height calc is fine).

2) Editor Logic (main.js)
- Initialization
  - Call `host.setTitle('Text Editor')` on load.
  - Load last session via `const state = host.loadState({ lastPath: null, draft: null });`.
  - If `state.draft` exists, hydrate the editor with it and set unsaved flag; else if `state.lastPath`, attempt to open that file.

- Open flow
  - If user clicks “Browse”, open a modal using `/api/browse` to select a file and put its path into the input.
  - On “Open”, call `api.get('read?path=' + encodeURIComponent(path))`.
  - Set editor value to `data.content`; clear unsaved flag; set `host.setTitle('Text Editor — ' + basename(path))` and `host.saveState({ lastPath: path })`.

- Save flow
  - On “Save”, call `api.post('write', { path, content: editor.value })`.
  - On success: clear unsaved flag; `host.toast('Saved')`; update state with `{ lastPath: path }`.

- Unsaved changes
  - Track edits and set an `unsaved` flag when the buffer differs from last saved.
  - Register `host.onBeforeExit(() => unsaved ? { cancel: true } : { state: { lastPath: path, draft: editor.value } })`.
    - If you return `{ cancel: true }`, also surface a UI hint (toast/modal) prompting the user to Save or Discard.

- Draft autosave
  - On every change (debounced), call `host.saveState({ lastPath: path || null, draft: editor.value })` so a quick refresh/home preserves work.

3) File Picker UX (optional first pass)
- Implement a simple modal listing from `/api/browse?path=<current>` with folder navigation and selecting a file populates the input.
- You may implement a minimal inline picker first, then iterate.

## 6. File Layout
- `/app/apps/file_editor/template.html` → Editor UI structure.
- `/app/apps/file_editor/main.js` → Editor logic; export default `(container, api, host)`.
- `/app/apps/file_editor/main.py` → Backend endpoints (extend if needed, keep response shape consistent).

## 7. Definition of Done
- Open a file from home using Browse/Open.
- Edit text and Save writes the file using the app API.
- Title reflects the editor and current filename.
- Unsaved changes block exit (or warn) via `onBeforeExit`.
- Last opened path and draft restore on reload via `host.loadState`.
- No writes outside home directory; errors surface as toasts or inline messages.

## 8. Notes
- This app is a Text Editor; it is intentionally labeled “File Editor” in the launcher/UI.
- Start with a `<textarea>` implementation; a richer editor (e.g., CodeMirror) can be considered later.

## 9. Run Context and Permissions
- Working directory: run the agent from the project root so it can read core docs and templates (e.g., `CORE_API_MANUAL.md`, `app/main.py`, `app/templates/app_shell.html`).
- Write scope: restrict all file writes to `/app/apps/file_editor/` only. Do not edit files elsewhere.
- Recommended enforcement: if your tooling supports it, set a write whitelist to `app/apps/file_editor` and fail any attempted writes outside this path.
- Local APIs needed by the app (at runtime, not by the agent):
  - Per‑app: `/api/app/file_editor/read`, `/api/app/file_editor/write`
  - Core: `/api/browse` (picker), `/api/run_command` (rare)
- Testing locally: from repo root, run `python app/main.py` (port 8080 by default), open `/` to see the Apps Launcher, then open `/app/file_editor`.
