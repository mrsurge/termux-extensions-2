#!/data/data/com.termux/files/usr/bin/bash
# te-path-execs: Enumerate unique executables on PATH (JSONL + caching)
# Logs: $HOME/.cache/te/te-path-execs.log (set TE_LOG_DISABLE=1 to disable)
set -euo pipefail
IFS=$'\n\t'
VERSION=1.0.0
CAP=800
TTL=30
CACHE_DIR="$HOME/.cache/te"; [ -d "$CACHE_DIR" ] || mkdir -p "$CACHE_DIR"; chmod 700 "$CACHE_DIR" 2>/dev/null || true
ENTRIES_FILE="$CACHE_DIR/path_execs.v1.cache"
META_FILE="$CACHE_DIR/path_execs.v1.meta"
LOG_FILE="$CACHE_DIR/te-path-execs.log"

usage(){ echo "te-path-execs [--no-cache] [--version] [--help]"; }
case "${1:-}" in
  --version) echo "$VERSION"; exit 0;;
  --help) usage; exit 0;;
  --no-cache) FORCE=true; shift;;
  *) FORCE=false;;
esac
[[ $# -eq 0 ]] || { echo "unknown arg: $1" >&2; exit 1; }

now(){ date +%s; }
path_hash(){ local IFS=:; printf '%s\0' $PATH; printf '%s' "$VERSION"; }
hash_path_sum(){ path_hash | sha256sum | awk '{print $1}'; }
json_escape(){ local s="$1" out="" c ord; local i len=${#s}; for((i=0;i<len;i++)); do c=${s:i:1}; case "$c" in '"')out+='\\"';; '\\')out+='\\\\';; $'\n')out+='\\n';; $'\r')out+='\\r';; $'\t')out+='\\t';; *) printf -v ord '%02X' "'${c}" 2>/dev/null||ord=""; if [[ $ord < 20 ]]; then out+="\\u00$ord"; else out+="$c"; fi;; esac; done; printf '%s' "$out"; }
truncate_name(){ local name="$1"; local max=256; if (( ${#name} > max )); then printf '%s\ttrue\t%s' "${name:0:max}" "${#name}"; else printf '%s\tfalse\t%s' "$name" "${#name}"; fi; }
emit(){ printf '%s\n' "$1"; }
log(){ [ "${TE_LOG_DISABLE:-0}" = 1 ] && return 0; printf '%s [%s] %s\n' "$(date +'%Y-%m-%dT%H:%M:%S')" "$$" "$*" >>"$LOG_FILE" 2>/dev/null || true; }

P_HASH=$(hash_path_sum)
log "start version=$VERSION force=$FORCE hash=$P_HASH"
trap 'rc=$?; log "error_exit rc=$rc scanned=$scanned emitted=$emitted dir_index=$dir_index"' ERR

USE_CACHE=false
if ! ${FORCE:-false} && [[ -f $ENTRIES_FILE && -f $META_FILE ]]; then
  declare meta_hash="" meta_epoch=0 meta_version="" meta_count=0
  while IFS='=' read -r k v; do case $k in sha256)meta_hash=$v;; epoch)meta_epoch=${v:-0};; version)meta_version=$v;; count)meta_count=${v:-0};; esac; done < "$META_FILE" || true
  NOW=$(now)
  if [[ $meta_hash == $P_HASH && $meta_version == $VERSION && $(( NOW - meta_epoch )) -le $TTL ]]; then USE_CACHE=true; fi
fi
if $USE_CACHE; then
  emitted=0; while IFS= read -r line; do emit "$line"; ((emitted++)); done < "$ENTRIES_FILE"
  emit "{\"event\":\"summary\",\"scanned\":$emitted,\"emitted\":$emitted,\"cap\":$CAP,\"source\":\"cache\"}"; log "summary source=cache emitted=$emitted"; exit 0; fi

declare -A SEEN
emitted=0; scanned=0; dir_index=0; DEADLINE=$(( $(now) + 3 ))
TEMP_ENTRIES="${ENTRIES_FILE}.build.$$"; >"$TEMP_ENTRIES"
OLDIFS=$IFS; IFS=':'; set +u
for d in $PATH; do IFS=$OLDIFS
  if [[ ! -d $d || ! -x $d ]]; then log "skip dir=$d"; emit "{\"event\":\"warn\",\"warning\":\"unreadable_path_dir\",\"path\":\"$(json_escape "$d")\"}"; IFS=':'; ((dir_index++)); continue; fi
  mapfile -t names < <( (cd "$d" && ls -1A 2>/dev/null) | LC_ALL=C sort ) || true
  for n in "${names[@]}"; do
    [[ -f $d/$n && -x $d/$n ]] || continue
    ((scanned++))
    if [[ -z ${SEEN[$n]+x} ]]; then
      SEEN[$n]=1
      read tn truncated orig_len < <(truncate_name "$n")
      en=$(json_escape "$tn"); rp=$(json_escape "$d/$n")
      line="{\"type\":\"exec\",\"name\":\"$en\",\"resolved\":\"$rp\",\"dir_index\":$dir_index,\"executable\":true"
      if [[ $truncated == true ]]; then line+=" ,\"truncated\":true,\"original_len\":$orig_len"; fi
      line+="}"
      emit "$line"; printf '%s\n' "$line" >>"$TEMP_ENTRIES"; ((emitted++)); log "emit name=$n dir_index=$dir_index"
      if (( emitted >= CAP )); then log "truncated scanned=$scanned emitted=$emitted"; emit "{\"event\":\"truncated\",\"scanned\":$scanned,\"emitted\":$emitted,\"cap\":$CAP,\"source\":\"live\"}"; mv -f "$TEMP_ENTRIES" "$ENTRIES_FILE" 2>/dev/null || true; exit 0; fi
    fi
    if (( $(now) > DEADLINE )); then log "timeout inner scanned=$scanned emitted=$emitted"; emit "{\"event\":\"timeout\",\"scanned\":$scanned,\"emitted\":$emitted,\"cap\":$CAP}"; rm -f "$TEMP_ENTRIES"; exit 3; fi
  done
  ((dir_index++)); IFS=':'
  if (( $(now) > DEADLINE )); then log "timeout dir_loop scanned=$scanned emitted=$emitted"; emit "{\"event\":\"timeout\",\"scanned\":$scanned,\"emitted\":$emitted,\"cap\":$CAP}"; rm -f "$TEMP_ENTRIES"; exit 3; fi
 done
IFS=$OLDIFS; set -u
emit "{\"event\":\"summary\",\"scanned\":$scanned,\"emitted\":$emitted,\"cap\":$CAP,\"source\":\"live\"}"; log "summary source=live scanned=$scanned emitted=$emitted"
if (( emitted < CAP )); then printf 'sha256=%s\nepoch=%s\ncount=%s\nversion=%s\n' "$P_HASH" "$(now)" "$emitted" "$VERSION" >"${META_FILE}.tmp.$$"; mv -f "$TEMP_ENTRIES" "$ENTRIES_FILE"; chmod 600 "$ENTRIES_FILE" 2>/dev/null || true; mv -f "${META_FILE}.tmp.$$" "$META_FILE"; chmod 600 "$META_FILE" 2>/dev/null || true; else rm -f "$TEMP_ENTRIES"; fi
