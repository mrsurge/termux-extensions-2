# Terminal App Agent Instructions

Purpose
- Provide a full-page app (app/apps/terminal) that embeds interactive terminals managed as Framework Shells.
- Keep terminals hidden from the Sessions & Shortcuts “interactive sessions” list by ensuring TE_SESSION_TYPE=framework.

Constraints (inherit from CORE_API_MANUAL.md and PLANNER_GUARDRAILS.md)
- Only modify files in app/apps/terminal/ unless explicitly instructed to adjust core.
- All HTTP responses must use the envelope: { ok: true|false, data?, error? }.
- Prefer Core APIs where available; add per-app endpoints when scoping improves safety or UX.

Runtime model
- Each terminal is a framework shell launched under a PTY managed by FrameworkShellManager.
  - Command form: [bash, -l, -i] (or [sh, -i] fallback), attached to a pty.openpty() slave.
  - ENV includes TE_SESSION_TYPE=framework, TE_TTY=pty, TERM=xterm-256color.
  - Output from the PTY master is fanned out to subscribers and appended to the stdout log.
- Input is delivered by writing directly to the PTY master (bytes).

Backend responsibilities (backend.py)
- GET /api/app/terminal/shells — list shells labeled "terminal-app".
- POST /api/app/terminal/shells — spawn PTY-backed shell; label = "terminal-app".
- GET /api/app/terminal/shells/<id> — return shell details; accepts logs=true&tail=N.
- POST /api/app/terminal/shells/<id>/input — body { data, newline? } -> write bytes to PTY.
- POST /api/app/terminal/shells/<id>/resize — body { cols, rows } -> ioctl(TIOCSWINSZ).
- POST /api/app/terminal/shells/<id>/action — { action: stop|kill|restart }.
- DELETE /api/app/terminal/shells/<id> — remove (kills if needed).
- WebSocket /api/app/terminal/ws/<id> — bidirectional stream: server pushes PTY output; client sends key data.

Frontend responsibilities (template.html, main.js)
- Render a list of "terminal-app" shells; allow creating, selecting, stopping, killing, removing.
- Use xterm.js for the terminal emulator; connect to WebSocket for live output; send keystrokes over WebSocket (fallback to HTTP when WS not ready).
- Optionally call /resize on container size changes for better UX.

Operational notes
- WebSockets require a WS-capable server in production. Recommended: gunicorn -k gevent (see WARP.md). The dev server typically works for local testing.
- xterm.js is loaded via CDN; if running fully offline, vendor the assets under app/static/ and update template.html accordingly.

Security
- If TE_FRAMEWORK_SHELL_TOKEN is enabled, Core framework endpoints require X-Framework-Key for mutations. This app’s backend performs spawns/controls server-side using the in-process manager, so no token is required in the browser for these per-app endpoints.
