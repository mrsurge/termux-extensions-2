import os
import json
from flask import Blueprint, request, jsonify

shortcut_wizard_bp = Blueprint('shortcut_wizard', __name__)

# The user's home and shortcuts directory
HOME_DIR = os.path.expanduser("~")
SHORTCUTS_DIR = os.path.join(HOME_DIR, '.shortcuts')
METADATA_DIR = os.path.join(SHORTCUTS_DIR, '.metadata')

@shortcut_wizard_bp.route('/create', methods=['POST'])
def create_shortcut():
    """Receives shortcut data and writes it to a new script and metadata file.

    Supports either a single command (legacy fields: command + args)
    or multiple command blocks via data['commands'] (array of {command, args}).
    Joins multiple commands with a pipe (|).
    """
    data = request.get_json()

    if not data or not data.get('filename'):
        return jsonify({'error': 'Filename is required.'}), 400

    filename = data['filename']
    if '/' in filename or '..' in filename:
        return jsonify({'error': 'Invalid filename.'}), 400

    # Validate commands
    commands_payload = data.get('commands')
    if commands_payload and isinstance(commands_payload, list):
        if not commands_payload:
            return jsonify({'error': 'At least one command block is required.'}), 400
        for block in commands_payload:
            if not isinstance(block, dict) or not block.get('command'):
                return jsonify({'error': 'Each command block must include a command.'}), 400
    else:
        # Legacy single-command path
        if not data.get('command'):
            return jsonify({'error': 'Command is required.'}), 400

    # --- Assemble the script content ---
    script_content = []
    if data.get('shebang', False):
        script_content.append("#!/data/data/com.termux/files/usr/bin/bash")
    script_content.append("# Generated by Termux Extensions Shortcut Wizard v1.3")
    script_content.append("")  # Add a blank line

    # Assemble env vars prefix
    env_vars_str = " ".join([f'{key}="{value}"' for key, value in data.get('env_vars', {}).items()])

    def build_args_str(args):
        args_list = []
        for arg in args or []:
            option = arg.get('option', '')
            value = arg.get('value', '')
            if option and value:
                args_list.append(f'{option} "{value}"')
            elif option:
                args_list.append(option)
            elif value:
                args_list.append(f'"{value}"')
        return " ".join(args_list)

    command_lines = []
    if commands_payload and isinstance(commands_payload, list):
        # Build lines based on whether the command pipes to the next
        current_line = None
        prev_pipe = False
        for idx, block in enumerate(commands_payload):
            seg = f"{block['command']} {build_args_str(block.get('args'))}".strip()
            pipe_to_next = bool(block.get('pipe_to_next'))
            if current_line is None:
                current_line = seg
            else:
                if prev_pipe:
                    current_line = f"{current_line} | {seg}"
                else:
                    # previous block ended the line; push it and start new
                    command_lines.append(current_line)
                    current_line = seg
            # Track whether this block should pipe forward
            prev_pipe = pipe_to_next

        # Append the final accumulated line
        if current_line is not None:
            command_lines.append(current_line)
    else:
        # Legacy single command
        args_str = build_args_str(data.get('args'))
        command_lines.append(f"{data['command']} {args_str}".strip())

    # Join with pipes if multiple; prefix env vars once at the beginning
    # Prepend env once on the first non-empty line
    if command_lines:
        command_lines[0] = f"{env_vars_str} {command_lines[0]}".strip()
    script_content.extend(command_lines)
    script_content.append("\n")

    # --- Assemble the metadata content ---
    metadata_content = {
        "wizard_generated": True,
        "version": "1.3",
        "shebang": data.get('shebang', False),
        "env_vars": data.get('env_vars', {}),
    }
    if commands_payload and isinstance(commands_payload, list):
        metadata_content["commands"] = commands_payload
    else:
        metadata_content.update({
            "command": data.get('command', ''),
            "args": data.get('args', [])
        })

    # --- Write the files ---
    try:
        os.makedirs(SHORTCUTS_DIR, exist_ok=True)
        os.makedirs(METADATA_DIR, exist_ok=True)

        script_path = os.path.join(SHORTCUTS_DIR, filename)
        metadata_path = os.path.join(METADATA_DIR, f"{filename}.json")

        with open(script_path, 'w') as f:
            f.write("\n".join(script_content))
        os.chmod(script_path, 0o755)

        with open(metadata_path, 'w') as f:
            json.dump(metadata_content, f, indent=2)

        return jsonify({"ok": True, "message": f'Shortcut "{filename}" created.'}), 201

    except Exception as e:
        return jsonify({"ok": False, "error": f'Failed to write shortcut file: {str(e)}'}), 500

@shortcut_wizard_bp.route('/list', methods=['GET'])
def list_shortcuts():
    """Lists all scripts in the shortcuts directory and checks if they are editable."""
    if not os.path.exists(SHORTCUTS_DIR):
        return jsonify({"ok": True, "data": []})

    scripts = []
    for filename in os.listdir(SHORTCUTS_DIR):
        if not filename.endswith('.sh'): continue
        script_path = os.path.join(SHORTCUTS_DIR, filename)
        metadata_path = os.path.join(METADATA_DIR, f"{filename}.json")
        scripts.append({
            "name": filename,
            "path": script_path,
            "is_editable": os.path.exists(metadata_path)
        })
    return jsonify({"ok": True, "data": scripts})

@shortcut_wizard_bp.route('/detail', methods=['GET'])
def get_shortcut_detail():
    """Gets the metadata for a single editable shortcut."""
    script_path = request.args.get('path')
    if not script_path:
        return jsonify({"ok": False, "error": 'Script path is required.'}), 400

    filename = os.path.basename(script_path)
    metadata_path = os.path.join(METADATA_DIR, f"{filename}.json")

    if not os.path.exists(metadata_path):
        return jsonify({"ok": False, "error": 'Shortcut is not editable or has no metadata.'}), 404

    try:
        with open(metadata_path, 'r') as f:
            data = json.load(f)
        return jsonify({"ok": True, "data": data})
    except Exception as e:
        return jsonify({"ok": False, "error": f'Failed to read metadata file: {str(e)}'}), 500

@shortcut_wizard_bp.route('/delete', methods=['POST'])
def delete_shortcuts():
    """Deletes one or more shortcuts and their metadata."""
    data = request.get_json()
    if not data or 'paths' not in data:
        return jsonify({"ok": False, "error": 'A list of paths to delete is required.'}), 400

    deleted_count = 0
    errors = []
    for path in data['paths']:
        try:
            filename = os.path.basename(path)
            metadata_path = os.path.join(METADATA_DIR, f"{filename}.json")
            
            if os.path.exists(path):
                os.remove(path)
            if os.path.exists(metadata_path):
                os.remove(metadata_path)
            
            deleted_count += 1
        except Exception as e:
            errors.append(f"Failed to delete {path}: {e}")

    if errors:
        return jsonify({"ok": False, "error": ", ".join(errors), 'deleted_count': deleted_count}), 500
    
    return jsonify({"ok": True, "data": {'deleted_count': deleted_count}})

@shortcut_wizard_bp.route('/read_raw', methods=['GET'])
def read_raw_script():
    """Reads a raw script file from the shortcuts directory for simple viewing/editing."""
    script_path = request.args.get('path')
    if not script_path:
        return jsonify({'error': 'Script path is required.'}), 400
    # Restrict access to ~/.shortcuts
    script_path = os.path.abspath(script_path)
    if not script_path.startswith(os.path.abspath(SHORTCUTS_DIR) + os.sep):
        return jsonify({'error': 'Access denied.'}), 403
    if not os.path.exists(script_path):
        return jsonify({'error': 'File not found.'}), 404
    try:
        with open(script_path, 'r') as f:
            content = f.read()
        return jsonify({"content": content})
    except Exception as e:
        return jsonify({'error': f'Failed to read file: {e}'}), 500

@shortcut_wizard_bp.route('/save_raw', methods=['POST'])
def save_raw_script():
    """Overwrites a script file in the shortcuts directory from the simple editor."""
    data = request.get_json() or {}
    script_path = data.get('path')
    content = data.get('content')
    if not script_path:
        return jsonify({'error': 'Script path is required.'}), 400
    # Restrict access to ~/.shortcuts
    script_path = os.path.abspath(script_path)
    if not script_path.startswith(os.path.abspath(SHORTCUTS_DIR) + os.sep):
        return jsonify({'error': 'Access denied.'}), 403
    try:
        with open(script_path, 'w') as f:
            f.write(content if content is not None else "")
        os.chmod(script_path, 0o755)
        return jsonify({"status": "success"})
    except Exception as e:
        return jsonify({'error': f'Failed to write file: {e}'}), 500
